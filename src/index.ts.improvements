// 개선이 필요한 코드 예시

// 1. 메모리 관리 개선
class EVEMCPServer {
  private pdfCache: Map<string, StoredPDFDocument> = new Map();
  private maxCacheSize = 10; // 최대 10개 PDF만 캐시
  
  private addToCache(url: string, pdf: StoredPDFDocument) {
    // LRU 캐시 구현
    if (this.pdfCache.size >= this.maxCacheSize) {
      const firstKey = this.pdfCache.keys().next().value;
      this.pdfCache.delete(firstKey);
    }
    this.pdfCache.set(url, pdf);
  }
}

// 2. 더 나은 에러 처리
private async downloadPDF(args: any): Promise<any> {
  try {
    // URL 검증 추가
    const urlPattern = /^https?:\/\/([\w.-]+\.)?[\w.-]+\.[a-z]{2,6}.*\.pdf$/i;
    if (!urlPattern.test(url)) {
      throw new McpError(ErrorCode.InvalidRequest, "Invalid PDF URL format");
    }
    
    // 타임아웃 추가
    const response = await axios.get(downloadUrl, {
      responseType: 'arraybuffer',
      maxContentLength: 50 * 1024 * 1024,
      timeout: 30000, // 30초 타임아웃
      validateStatus: (status) => status === 200,
    });
  } catch (error) {
    if (axios.isTimeout(error)) {
      throw new McpError(ErrorCode.InternalError, "Download timeout - file too large or slow connection");
    }
    // 더 구체적인 에러 메시지
  }
}

// 3. 향상된 PDF 검색
private async searchInPDF(pdfDoc: StoredPDFDocument, question: string): Promise<string[]> {
  // TF-IDF 또는 BM25 같은 더 나은 검색 알고리즘
  // 또는 임베딩 기반 검색
  
  // 섹션별로 분리
  const sections = this.extractSections(pdfDoc.content);
  
  // 각 섹션의 관련성 점수 계산
  const scoredSections = sections.map(section => ({
    text: section,
    score: this.calculateRelevance(section, question)
  }));
  
  // 상위 N개 반환
  return scoredSections
    .sort((a, b) => b.score - a.score)
    .slice(0, 3)
    .map(s => s.text);
}